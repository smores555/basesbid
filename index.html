<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc4844557b170aa46d127c6ffb74806d89e00e888398ba106bf77577a14ac98330bb721ec9c3e8d987477bfe73c595d1d37874fb9bfdca4cc9078e0e3e784fd66ed426d4e775e4cfdb9616c1dc95b4a0aeec0f1613900d17dc9be925f7b65dbbd5b1811f74f06e548f2364ebef5e2ea9834738572c90e57822cd4261285d0834618a9845f6138bf8d6defa80647fa81da6950ec12e596cf0ef2e4f2ca17608747347a35557882e2c1965cf0d66224e79119fae39d72aa2534672b951f381a1f03701e5ad4637b0a2e0ad400b7b32acacc411d8b53e6ba2aefe93dd66a30081d611f693d4285181dd1f7366f867ddff0803c4a3b5daf075c773d3876d81f6734813272325d271577ee7d265565c5ba34338cc1afb8f9470816cb2dac22f6f5d91bae5b1faacd59d78bc3bc0a7e596b39a1abde1980deb80b1d0487518e5c10a04cf65312d62a3ab5c008643ef8c97f480cc15d18d2f0ad901670848188b6e692106148b3bdcec7b290d28071d7c794a1b03f5d6e6e8553b959b01a78ff0e5f64bb2a11180a71a6e87f07b93d9e3d2d9d5efd28b450e04319acbf33a0c968cd4b09bc61a46439a31722f03641ccf499e72566638e3768a1b95bff141d88b58049d5958849eac954e1a2b2de8f1f521f6c7780f84bb903dda9f17a808e84c769c7b447cf2f950c9744e57753b69888dd35dbfd2291684e1497101567879996577baf171caec3f9b44a66d582085749f2f1bb52fc4a3965509ae8d33810271a4c9a6d23d46dcadc407d2b21deef0d5e53ea20ea0e498bc22692c2d3791ca2538c3300ff7e031fbf44f6d15e85774d39b9fac4e9b6f644358bc7ed7019f62a6f1a05d508c3fbdc7e72ea500c485572175780693684689ad3f44b2211bb5550e346a64fd68e0c4bbac1fe4fc071e3d7c8d17afc647ac0987ac8095ed8161b634a0a0cbfa8eda70ef6766c7227c06a0749b677d21542bbbda5f399260a3c461f1e0ad40e18683ff17786d931a88791eca48dc731fba44412ee6ae0d1b31b1e76a8b1dde77d09acf484ea047cd2cbd02b31814bc87eae234d44f78e097a8cb1ee1c815d309d15afc701a1394bfda2d543cc959c36e95fa4f1bc3788d48208cf945a0f293d50bd80ad608b1ee5e01123367b230b169ebfc8f38b455dc8e8e294a502151e5fcb346f4e04cc8e785cd041d8044a9f2638bd27234c7f87ed42e398d4e4c011c3a4d7d968f6368ace467c7c82595c39328f803454edb29894a3899ab06efe9dd3f00f29a29d2b6ea4e5e743cd667219cf479649fa61ce96ea4b918854a26ca5531a1894f4ca1176eed5bc2e42b2665ecf2a0e37a22698f8c7dd232fa2d81abed0c5844154d1fd626d497cc9c6509b61ceeda376a0e881b4f9691a637b39443698274d5e699061d457a23cd6435e6f0e1ca706c2592a0a9cd175838297c7b8404511ec43a4f4b6f49b1908939ddf3aaaaa407ec7446a0e221f6eb0c524aaf161080ede34cb40a8b73c44190f383c01529b046a12c08d6aec54b2ea2b2cdcd2e85352df54b3c52f8638f41a5c480183efb7e0b0b20efb0a918ef32e625d10d1e201acb1bedfc1e80d88d806168660ca9a75717777af7cdbe7f5750cece34feba2f95a354784a064ece9611fa3347d5ce3bd3a9971dcc83af25074a83681f3ad712f0944303deaf4852e7d2d1177fd42bd7fbb0d8e5f888f214aad0a16d5d759026e9fe5a5a05bfafbe613cb47e164e05ab8a9c641290b59ab1ccd8315c468847c93f0742f53c41b9b393fd8320e50528b5de0451fa338b072cc883a345fe79083def84ad78eca2b83c617fde37c7aefb8454f7f7a34a2252a497434dfccb715445a1cfcd242f73ad9d3d40d1a19ac0c1fcdbc0b19d7ee45ac853fcbabd55b5a4392b8704980e1550b527614d66dbb6b168e36aa39bb989d38767ad554fcfe54d315e5a8f9393437e265a8a309e46d88a994fdddb744e5085b57166a03e75384fe1a24747065ae8a57e5770aecaddc90dd7fb1a666f38e9fa5829db83a131fdb6df8418996b111143ebe68a33631ed07f7f47961a1aa22c4000c351e9abcb635ef754263ed5e70c76de4d278c83bc28db10147e8b5a4da6031cab42b7c14f97fa2c202890fe3ead9e191e3d13ec107f52f50955cd1ff6f7b5d55a7118501e75535e69b0421437b09931050897ea6c92d23c098d9d8057d0adf9b898051bac7ec63a606b887349c0a196c4ada09fee9442ed78224acf4718020e3fcf789532a181e05bc09a562f5a098ee9a57aa23d9b75ee3ff629b0c956103d594eee897205b1d05a40787dc4b98eb8dbcd7ad3e09c777d29a00b40a41f8072fd239ba44327c97178af5e836eec59d1beb0985f143d0251ac251f89f65ef47d4f6e3b47842a402e9d9d0dc5245b12ff33ae9d8b84a62b86abfdf3402055d9884c4381c9bee4352f3f6149672165d1e3d3b2ebc75a671e265023eacf900b60d8305dbc41a58ffe44b75e4e8621c1bb4b4438b44ae8b14131b08fb8bf7b908c55699233d275b0789273e981851b8bdde072b74adc4c3f3d0ecdd5ac6e31f9ba18221a40c135d56ddb354eabae053221b024152c826b49eecb8f08eb3ab07061f4ce55397d1bd4f9202a820076b57b7f813f756b6cac2712f2271e05fb1b7ea00edbad6101aa2102a023f4e55f2baea2fefaecfcc8a5ad2c27fd8e594c91d06ded1daa61df93b8fa8cb10de607c68b89897404e49ec1a8443e8f418407e9f20cd0727b9c982ed9f3e846b5d9a5d06345f334513df7ce137382ed8be967e2bfd409fef02aa3fb677274f0179e26ce27cc033477cff9b355d8537af62bd01905eb0078c0a621cd8e46d7c323146131ceaf0fee89b10e24e43ced531418b4171c5aa083246b1ea45fbecd40abc91d1e9d0e0e40e9c93cbcbff4872fa4a306d4fb5dfb424dbdb88b38bdd91295c4331bb3ea0462661d7397707f04339b96d554db98f90d7933f551c1c246ea41142f45dcb5fc22847515a709fc30238e8a2470265d0a74bf1f2256ae7f19cfed970a6fbfce16fc44c756725bcc1161fb0a5472b835124d68ce18015d243869a4be9d078767fee41575468a630506d0a9b7ba0274f0442d37b434a8246f254ae6ca126ec36bbbe826f559742e5647f3d427d6b7216448161e4ef838a21f66c4544b1e85fdfa9bd255c749208c96e0c27e43e81f048aaa2842df10fb1ffcc4a5361af532939455f234288bb1c09c9c69825277713cb43940b3381cb4d8511a9b03ea088a6fc7c2a2646c60db56c51d355f24e65dedaad40efafe03c3ac7ae006a5d8fa8ec827a22335c74caec96d7b06371640a35dd9dc62e5686928eae72e94d3bf5bf51552f20151d85645f4c8fe8cb6f60271ef6366e34c0b974a25b2518ec3fa0307ae07772bd2bf49fffbdc2f706c8916b22901b0c76c668b8aaba91f2749bc13118a39036d198e18ba7e5d1077b5d501256ecec8739372495b92a344abc85c3faa6e02c3f87cd18909354fdec69385e374f1d24a4915232f127d8aacd6ceb397dca4ad95102b5f318baed5d19b80b9cac19333f8f48a5abfbd2642d6464d642842ae9f1e8f9cf5be9d29d31845a877827d725182153625a6766db13e9dc422b96482f1d8615a1b82ac6b06a57552dab37b9f8b46930fa063ea1e2eb6eb0f3dc828c30300cd92a39c47f3f4c11770cc76ce2119578981179dc097fbd0cdda04cfcced47000ae10fecc564568fd972bfbcf95bbb61b52a77cce72b3992f6948a8107ccee930f0e09d7f9f75e109815fdbd6a64ab3cb68e05e92054f0728c57d77f0ff9995f198a8ee023e15882ff8c182ad5dd1ab0cfbe68bb59534447cc297e9b27756f72371cbebb4899db93a4e51daefa36d3f9117ed33b97dc80b2121ee9025615bbf8bb97ea4e50debc868ad4d049b491795ce6832a16e416b7c74e04cdd995a6e9dd25e371473ca42a66ad9965fda127ac6fb269ce30365df3a85ddd257f6fd09d62606d0ec7bf32d7a4bf4d797f17bac6e93f541a37f5dda4d321456828fcf5468282026172bab5bedc63640f4e12044ad9014ff6dd976efb4d4cc32e989a6303882391df573dcddb95dab61a4b28e968180e967ef333ff9104dfba2e2c0812c57bf145bffa2e1418c07e1ba26dfcb70bdb78852c5e2eaeafb05cd26ac1c428e77b00154f05777495076b747c08f73651e126d13f3a045ad45585520de880c1139dbb0f779a820ebea61c9c4c3aede7bf9fe5b58ab611c3453d5e2b3997b51a49988c3030d018659d50ec040ac5f58baca5a003a24035a7dec39e166d4863af7f6da54cff2c5379e78aeec98b3219041b7b4e0aec5c853859a89036e8d99e3f96d889071994712fcb6c83163e3b1a3e49d38bd64dcea7cd11e312c0beef9d2c9a27ea4ea75aec5d1269a9942d38583034c0b1223fefcc4a8ca815e4a84f3916cf4a3b76dacc5e0d908076756a2e30eb4c91c26556ec49a218f985063c7da8bb7a3d815b1705d112115e7c79e861456390bdbbd196a169c98a623452d0cd5f71f3d646bea483c53a1a18d52b165e9e2cb98ce682f5f26cb11f7c4d7491ea092ce44bf448b56ede5e59a6983dc5cf65f43d66d2580d1ae283a2bfb460773b9da99cec7bb5f5c6007aaa4d6c66ee1043a7e352b0a51ccf46530899e7275ae70ea0c66d4c419930d66274b2d750bd41cbb1272a0b54c79630bf23e05a988c4c8ce9cfdbee2a714bbfa67bd6ca248b2b6d64a73832fd7a5b1b410aff39c3a6f0a218376a2071b6bf8932e265c1eb43105d77c15cb67716a5822049cefb75a284fe95674c72c6b73bf6950e908b8ba6a5efe70b87707f3b4cd566e139f40e6851385dcea424bae93999ad47d4801170f164348d09be12fce6db51ec040c3b009b7e76ecd28e3f4b2758b4edf7ff6cd3a05730ac572083a4bb1c160d9a203ebf9e6d334e1810d31bb545bef529b503d60ee9da6a04304bf44756a6dc590f6389e799ce94c55b22dd9b6d1073ffb23c4165b75aaead82f205cf5dc970b2c4f7d7c1083ea67e5de034762a1e77e93ddfb1f52d8076a8074652a7e8be852eb771af598909674c6a4dae696d6cdb07ac2aa919c06e05e43d19e8924afc42ad2e9f166c3aae23a9a54ee74591ab28075194ed56fd474e828f2398a0a81cad9899436f31f1b65ec06ae5be52ff16f378536eca0dc19867c1c36250413ff3f0ddf51cca6bfb58518f55ee1ebc2bd96a55437b55dced45ffed40b523fe5871263a95cf7026c2721784468e263ccef541efa739bbb410e28a085e70518bcb6718736635adba150100f377cd5187d69795902fddc09a3e4ea97caeaf29571c2813fc7b544f077598a807738c2bfdd2b063e00b30a71773286874b033cb0fbf7e059f45a79c508c718e90ced68d1c5ba81d270df4d905a8915f2807a00411819a744e3bcca051cad5dbe7b225241297b59cb206b08fc93e9a3f4dfe7e8d28c5845680d2999679840bd25bad4ea81999c179773a3522869c050080c08a9895779831f965e576cbf2cbc6b6940dc4fb5d7afc4d62273eb5a2172f146a793f596c0d39c89ab28a525b43b56527ef7b24c698d497aa2f3e3366b39eac472a120f760327ca8261b3d51761bb7509cb2590f8995373d62df6f60ad1094c61eb340a2bba7b5ce84ea641c018a9e5bdc6c5c4800e38cd973b0339169b2bfdb9f16c5ef23809e0d52043af05adf651f3e87825598e5c1d7230ddce23b5b3f52750250c5b364e275ff88c5603d48bd3e1c971c80a0836e68f2b6d91b224c37602d5e1675d0387b2eb75cf6ca6802f21ebe0f8ddb21729e0eebab649b685744d97e97d2b63e35bcf7d762e340a289d3c6023dc7c271659a1380bec66f3254c4af5e64871738ef23c8eb0bfa14f4f9f196136da5cb23b8f3b3b0862ad77ad388bd927f49d844242cb3ed91e4278d19aca1e9b84a9145e73287ed3619dbaeb8e510605e7b53e4f7c8c2d1fb4d8fabedd5183f101c7cc91183577acb63af3950f3146e786197ad505f1b7febf73e7e8649b0a14177e523d77671ce65ba20a7f0a5bb2ccf3536a4d69373963063715acaadbaf09421f7fff725757739629125d7049114b1f96d2e8a3c2411b28555080a9bba4684853a7813eecbee7ce2c4f13e53c70dca3167b8c7fe37d0cc845f1a69e4e366d429108780b57c48a79e8553681490c08bd921e44a921f2704b3db506f15d4b96b9688a3fb2e52d00f87a1f91b8b46c1ad66002919b731ddeec29467d0e2663ceb29928ab4aa5707addc74e51e99eac8c6d8ab2867239866ce885388ea4be4b08c82bb6c5ce3a8e061ed58d29687ec9658dcc86ac196b79dbe12325093d3b0c290f7e85dc63237bfb60f245c0573e7fcc320772a770a349ebaab6a36c32cf4ab13716a8bdf788cc686e4fb8a82e7716c0ddaaf58dad95c01c61dbc6c4112e5c9c321f0c7d15e6999ee4b6befb9df01454c144fad24f37e7bb59ef02434ba1c7becc03aa51afaf37bcf7db2da3844775a8ea0b2235ce2718fcb24df3be34255a70844cb98c1fa7373aa4eb084c5e19cc26149b5d5287f9dbf9675aa095e5c2499338090bd6ae3cb9b43b4b3a91b58203880ad6fdbc45a8bbc825577551fa4539ecbd8ece8fc6176d77061b0d232b298e595ace89a63a9ae1c77be2e87225543f1eda1571842bd5f9fd80c652f72c2c4b74636519e5b824d9025bb47593a0a3cfb18dbba08128e3369dec7a0aa56a3c770464d95a8173a2b3bd68f211fc1c30bfee5ef162f19c29f602f0bcf2d86f34984a2ef741aebf7aa7ebd399a3246a5317fe858731c483f98fb1b37f980a82633652a933cbab0a75293060b3b7c402605d6b980de57a49e44bb709889a550c353d30f326cab12d0819956e0bfcec4a59731d105c47761969b7292a576b4183cb3d17fe6d7bf99e6d782981dce0919c730ac5d4afa5019edb9ad59dc66704aa8d5569dbb2d0b439028e3328f5141de2194e12a715cac511e21f98999ebb5c07268118e484f997a8829c679933a20e0783f5ac1a869483e709b5ef0c14cf79e6464abbfa8ef38b5e330b691f308ef0367a97f8c58af0922973cf87239bf527801bcbe55172ec5638c4bf94452bb3399881fe806711f117f5c1434e3186855079d766673295276818075f9188abefa05106cdfb3cad6af4f71af23b2af95e08e6ce0920e21e9fd4cd6aa8b5533863abcd4e0f15a42c4e8ffcbd8f8deb8f15140f2778bbcddd56a55073a906dc40bd70b9c3424047e12223b6f01fc158a53a06ace15f9c10014b0eff2c8816f036ad5cde37b4bf0c753ef4ff886f91f7f997f97abd93aeb5e477e9f86033f9f8261c920de6a1ea2f9267e960047c4b1207398352e2dcfb1d4265566e117d2ea6091f7c6fd8bfa8853eb71b2cadda0aa63dfdecf66f48d6da554f1b24cce9875ac8969a449266b6767f3d5cd5015222c9d6c96ebcceae5d71cf0d97682a06be45022a6c74196fc3959e75af534900a1da463fd76452d2f351acc08eb701785ce69758a32f63b72caeac9a7e950d0e93fb3975897acf3645839ad1dce7994a1abfa95b7833b51bbfc4d9314bebda22a75a09d413b052ee7101f15dd16c0dcb9734a8c036161adf6d2ede96743f8b9ff363428fe86455eab089f6e5665935a1efea0cac5a758ee8994bc63d63f7d25d83c4d1fa00d8756fac8c904a583b283789bd06923a17e8b9355b8ddb22f934380569a1e3b5f7f9cd0895821736a7f6044d774ee3bcf3f19d30ee8bd8e4e3b0438858fb44bab417a3608f3ba75a9c41d7c64d991c1c673a4b51d73f043b9fa4f213e031b279f5dfceffbc8653c0d9153f28557803a3bfa6549010ed71f476bcde18893d7d4132ae029bbf81663e223b2fdee98bbe4ba0a1e227279c8b378bce7f45e0e8fb5f78772b16a03bf7ad4151f1a81ea2bd225fdb196e19dd069c3ea802557c48553f038d8522afcaffd15bfd695fffcf675d7787d5de91def4e06006206207b341c297fbfb03befe38d6e828cad950d995875e0963f67460487d0666120208b64933e599a96d32c951b8a361c5cfe5606b2f3696c2a457ce66b3c1a9812309c28e1c9a4012e2bff5332aa1266189bbe41f43ea6f4f232a5d0e756b3bd9ca5c0a576e73d734846d1882770dcd744b1102c49d398544a2929047e0d221b0d130d1062a967c44979d1a18e58d3ec68815ce99c6cadc8a72394be3e7a510370ad8c63f33ec934ce0e018980d98a7c80f7990514049f28a4c8c6c6f0459927c06fa11fce766143dc30c65090fd2f7d412d54ae6627e4c41ec41bf76454a6ef624067e552c062125d6ba77d890cbf50991e84a44e91363300162b112d4529c1825f92d9afac0f87470c32828307b9b28facee3b46369cbe4299f8b2159a85c0f83a06906efda113581ef6da64ea61b1a3cbe3f9ac6a759a38376a3e5fb63c5c282c409a5dfad19b300c5e344812c8ae41e9b9cb0555db761d1e65d753d46bf76cd5154bb08507dcfef3c94107353cc7a9cadb22bde7fb5a9a588564ea91f622e933a83deb409b8973916a40bb339d71d6bc78ee22845606bb5a15913c8170f180a9061393097bbd19071ce0df7a7a37857818fd9884dd6b5b819b424fa1d91c720c642c89ec71b32eed72c9d734f064bfff7efb84e3557f794c439c03f2f312627be6ec79aee18eeeadb42b7f14bf3222f395cf21f6c638ef8184dc2b17f832c4c291f61f3ded6f0add543ff3bfa115873272ea47a2b0471f2f9797aa72716045cc228a204689d00a8d7f71087e2e20cb34f043b4575339c94ccca0c4e8e2cb6e842e86b72b8e7935399b7e0d690eeab31fa86efe59c48c589ca0608aa284e62e102cc0e0423bbf4fb38698b1c96d3c209e7864c34f317870883c764c614a02f323f123f155ac5da8bb0bb54d73b80b18554761d677fe9e10a9256db5e162ff8c56d1240a328a08e02044dd54742e23b149b44b84c95dcd69925d83ca97ced3d7cef2c015fa1760e600d8daddc4d815c766123e3d61d9c813fd30bc86412c9a67eb70f71c876804ec905af3bf147d87b518f26d377f3c178ec51bc6aaff2d1ea3a8d5589f1b5f177de120a5a9382d55fbea704b49a54ba891524d3927b9f52598338b5b60f4716048a419ee03a97c4c8efcda85d0c04f7b8a0369e75ad32ee90a9c0c04c774d9bf47a9d092aece62af632f8ed7a91653fcaee6a37034c918a317cd7915c5b68cf06dfd4e655bf5ae3cb7843846e6f24aa44361dc57a87bcd9a44ad7fde4ad19229258a8d8d5ab9ad079e2a33e6e85f4f4141ea25bfcd6638672217580cd7ac779324d428bc7c4cf7fae18fd7d8bba375bcb5722f87acd711fd24090890ec6d924c5484a8d0d0e00c384a5eb5ad494b391be9678fc91aad0bba781ca0d462e8226856ee3e7930ab9ac292f8389fc3c7e4aa15b9b4666bf7a9dd1de562cd6a43e526f051102ee25ff6e29ec277c569d0df149147aba57ad712723870728af973a653cfb1e66c90287c681763ba724278a8f0d8b960cfeb026d597a019813e61022bf2ea492ea16747e7f9c4f8dd383a6ae61804af1348cf3be46ed8235f476b2a23febd70457aece489127a01c04ed2a9099081eac041fb3021df0183674dde5896ca368dd17df73f03d3a20867705984f32cfb82e6630a8c97075ba71db009854fb376e60099c5b9f83442cc3fe112bfa5a341fef1096d24be26ea19407fa822dc20a495fbd79fd7f967c4f5b5a73030729ac1167f8e0348b95a4ad07d52ec2a1f1ac4fb104977d1a571be105df6dcbdbf092158797c8e229f560e3d302af1889058ab831d9b5fef6c3baa2eeed4d6f7432ba45f185fe354d1f8c7e4b88f6e9fe0e1253e569c981c90b3e0550b1ebf05b9671ec3b7c139c0ef1baa54a44006fe99d5762ce04fa508e11c2454c43919a560dffeef0919fb7739f8e21a3936157fb87b55c9c643ac3b280f9d117828e963ad02bd6e02dd0b060fb3872405b6562c9a96d2293c3ad758d8f33a9ab35d022570ec8087251b7b359e9541353d1f47cdec5cdd78a010728c3cfbc85636fa5723178404489a029a18eb70c451d333e1add2ff9ad78e80a6cf8b90c779bad4775e03901fae4ea9b8078bd1ba80be22911bef69cc84d5a1820fe3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"6382b375fd1f20eaa4f6954ae5b4f26c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
