<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d2a2e9d92a466a00ce03240d459926f36996c75891556dec2a6c59a61c95adf2c5507c2d23f2c7ce21b8c76010cb13909b34d60186ca9900d85b1fa1cd97f8d4266ac48d258e8512f5fa27fd313347db539a1e22f7ebb3330587dd9e4a28c955cd8a03129e88588a0ebf5d778e73f8f8e7b2b6e4d967f15ca2a79654ea5a0d256db6b802efb01fa94967dda9d7880e1d594c00e747ad6140bec44bf012aec937d1b2f283296acacf8fb0bbfdbdfd7ea72b12d5d5f9f12d4409051508f55aa3580549951a6e5603d65928724efec5eb97b61ecbb16d55de5dc0394bdd71381003a0ae9728406a976ac44e5488a02d543bc23f6f3407b144476b69f48362ee09cd61fb19a8ecce18df6521cf46a44c4fa00ea9ce7dc17ef1226efc8756a6d36c621f3ce4b30621789b0d080db665caf549b6175e866325e56c4124f59aa64cc9cc3d6d749355867d5a90793b4ad9f2c0435bf0e0dc1c785c1d9e8d891daa4cdcd89260f4b7fc51cbbff7a7b58fd2edb17b0964162bef663dea7418e3344aaa0dfcdd18842564c5cb150cb828bc5b0179a4ac4ccb016861b2f4c11b05c73000377c7a8df50470cebdd3e81d0ed83010d54f5dad139b02e005ec1500b031fa6d0908336ba877c16f97cc6402bda9ac36ba3f282ff9b5f4ec2c73713ab9b360139b06ec4edabca61c2a0288e0200dcc11b1f3a01b667e68797e86d88b0e6d3324f329d8f3f77df3a25ecbabf80db8813e94d6930a7d6c905d09a90a0eae8cea03ae4792e26eb26cc323b47f7030e0ef9ac88adbd4d4839d8b1e93b53c02c991f84012446775695094455ec220afe97f98d1356de7bef12f6d832ebc53b5376fa816fd4704e5b43494017fb24a790923c71effc1a6373fd95d1f164b375ee8cfb770e496daecd48c3a5dcb7109eb8ab00e9f4fed72bf4d1d204d22ed8208585b735cc3a88518c7d17a25b32b03cb44e259f883e8f97e89ed13ce42623e7ae2786aae39c4cf8c9bc8887318fa2b60131cc95d9f9dffa314deac748ad199d0281a00ddb95232f16fe7f1a6d45262ae03abe538647f920b0db73204d52ef187b4602afc79548577401a99871e5fff07aeffbdcde21d272ee09f8881453a229300d882a6ad2bee21416d6d976acd6d45bbf68367047319aab82827dd78b183c4785ff98e05d931919f4eab61c8e3f09dd105e4a64e7489f5aa2e5c5e7f336812e93b689258875f24bc446219806272ed74bfb0765f96c8ff980f15b9311a239b6ee206eb3f468bb0e1ebb0253a01f7a6e332add7a1868d25249adec1b1b676d009f3963397e8b06590f4f45b0ffbe31b63f45ddcba07698a0fbc0b57d2a15dedc5c55b4547969a9d406e458bc00403f1f4fdc7403c0fc09f39d4acef2675d0b2bb71361c673f91a7557eb3de71450d5b2b09551ac8117a9ee92a23215933da096da4db7515c080e01d5977ed844dabc30b9cc9c546cb6b387aee3613d718dde203bacf4dade5012de096e7765135505e5de7d3d7b4501a4e359352b20cdf258030d9ecf60c0cf0ccfc53226c26950d83d48d0cdfa39eee0a587e4f2155d8a0467886bf67e747a0d1ce5da95880886f38a3af477370950022d3145342aa21fe257bae627f7887976b46f9a33c365ed32b95afb34a749d22a1649ed8b3c53fa3c605c23ed2f212acf598f3bd4f7002bbe69c515fe1ca69ffdd0345a831d77bb0af237a7ea101bc163e9f1cdeeb02944c89aeceb36de6306a39f9e515895c1feff6dfe23d4f3c937a1209052cd0fd13d817a52652e1e50d5a3f18708fc4197817c0440376263067f72ff3cda4d9a6204265798d5bb054cbee8db55261f567859cddd7dc9a47356e71bc70a84156a7e5bb8297b932d612bc97a4f6418f5346fdce9c960617fd2db6c52afde014eca6755a2a40205491848291a3bf9ce9763fac3aee59cd5dcc3a9bab58644b867e324cb51be7d1dc91c49ef6265b68a8b93dcd98a1c458a1f16bfa2472fd68432a7956605394c2703740f93bb207e82941b3499cdabfc1a8a4f671f0cebe400b23ca8bc59ee3e516967b4bcfb7bf28cb450fea92e78e19f73469edb5ed206119041f45c20c342e05e6c7c10ca7db4030546df06562b18afbc1f0e9d5a02ac7ceef290db3a9285229760aed931227c12bb02050257371ae862eb617f94459f1c9091bbed7b3c3f82aafc779f605680a3848b368213afd35c219f217acd8c14203e5d85bf7fcff6bb736c36f520b78be654eb9e0f51eaaf41639cca019860627379de58649b995319ebcf87b5f848da76569d3583c2ffb27cd7526b73d9c170af5c2cbb54344be98c05722c187b21b4d5fe7fa3cf493ecf8e9e264cd252d06f835cce3a2c81905e2b44f3459ef6ecded84b35030c60e654512e6b4aeaa7df56db1efc2368d263b2ca64dcf21fa40273fdd8792a65c705de986b94f74d5c8bba81be486b7e687a1e74ae9bc2cc70af9fed2783e6c99deaa5beb628aeedc725094934cdbbb0192e59542bf2384dc314ca8dd129675c505c6fdef91d879bfb0623645552cadb6ab04ac1167d350ad3e36e2d961e0e4e29b665bf378b019d167d392449eb626858e02d7b05d560468adac5ddf31a3b642b0c5ff93ac63ec9ac1db549cbffce7a4beb69c4d39a79b8eef66d6d3bbdeec17279085e0e9854bd723142422d1aafd0eb15a9873ec4f44ede35a43dbe944766f24794c59e0d57f6891103c1545d15381db3c8f0e0bb4bb48bc0b057fdfea7d27b8412e97f58f374f5bfbb16cbcb7c82c145bba530edf41f054363ab518eb47c7f699ba2a898d4f2b4c5044640da6b15f53ec421cdc42665607053fedf12b44ea2cc25ec3e5f51a313a922903e44191a2efba4cfd90d0346db33bdcddcb7e13cdb92fd4018f9c2c19b4cb6aae75e925ff90ea37eeb67c2f98dd31fb58b088705941480c62ec0f473ccb8e20aeff06c3e36c2cc2c60bf0ca801e587d4d16d97755ff726f9eb9a359a7e3998da0ecf0bafd47cd5032de1820b78cf64a8022f4e632697847137c2de27b8b15a97ebf337a3bdd5fc4c7c06584757b3e9b4cdc992caaaa5054745d9a156d6ce5a407b8742f561483292512e0525aa496be39eed99101559d6f8084c8887338a6d66a5184189d7b0f819f8affd1012112ca9c7d3b6a43dc06dfc2614ee4492a27496a2a2d7e75f1cfb84881d62526d0d634d053f3661a20da539a0b6dcf67f332e06e5e3a07fe9ce12b9d95f37cae9425921eced1848f61889f55384a8b6219e6e1f4d312f94e1fad00086163532efe30be4f73a78d3007a4c220b0ced6ac29af07217900dad26dc12245ab0c135dfb9cf32190906912c7082ed806429b8c8c51297e07c4320527d35e2e00dc70568b9ae2ed27c823fe7a35d15251f0e192bab1220793ef09113ec744e2e4dc36920d7e795d8122d8da03d3a9de40245b275fed900df7fe46f64d873cde64a5afd2cbd411795fdef8444b35c7693287b97685f8c7607c43015196e93b8195623e2b7372e1114d5b26d5d895692f274e88d9b5d395a656508dac29ec6724ec9f262903440afcc8fd33c3a2300f39499a5993182545f3b294199ac561efb719c7c0459347276f4469a7cdfd46a09d005c9a26e0622ef3947f478cb50464d22516c7be9824ef47688f8941f08a67641671b30f8c0fd76875764848238c9f7a49f31ffde72aa6592434a18ca88d605fecb9f44170f404cc35f55694ed6cb374ff1212b63ad11372f322f40e3cf4acfb608c24f9a07b6624f4a7a63d6d3b44c0d631ef9ae907ebe94dc0da86adbf5fbbef83b7dc6827f96ac3a40a11595a8c3934687d86820424cf04b01bc0fdf3676a1bec94ce8110a59551c29d0dd244085e42ceab276f4e4403b2ca328d9f7bebb312fe8124267f8f05425f5a8da3f007ccb6b1fecaf4cbaf33bc9afcccfb7a34c33d277bbbb4fa3070cc8b7b3760ee0c271896fa940f0e47ae6ae7139066834e121200ae390b06967faf1e19de4a0b43ba6cab96c1f2b457e480c38cad562682fa7df22ea7bab567418c4c019788e03f9ebf921813d1fe58d87284620a841cfe37a6b7d8bc5a15915a5e4f4e45ef03f934c66799ca826cf1326dda88b2f324749d515d4dc62cabb158d5e87a45756b73f0335787cf5480b52a43b8ac5062c928f7dcf52e0f1288f5b59c291304ce8104b50eba094bc808591ebaf53d2efb1ebb73270acca81fb3e984dc97084222145b366e9b3659bd2215ddfc611039873dc947742fdb1304e9fa5ee7dbfa43a9258809fda2f690a7ac3be4ecf12d705377a88540ae3ee17f9a460adff9f93f4a5924586fe585159dc6068001e9bd65fb344218189e89f6fa04fc8e7bc742d017645be14b44443367015135064aedd86e2a3efe00856b01def8ab91c1382bb138499574035c6a1cd7aa4b5987e7070e01e37daece0887b742450e5143f2241de4c163d9a0de3b5b274ca7c56bc1f4cbf6456e96edcb1db248957ee4b3477933e1e2679f77b92af5f13dc3875c866c627fe3d74ce553f6b1c33b3b47622411380ffdb52c523b0be14b0ef7630a9e68500d85c10492e1f645b1c8fd3ef04d041fafbcd82a4efa3020acc54a36826ecf2feeec733959237651f2efaba8b2ea3d76beb00b6accfb5d178b3c6929381c05e12e299323cd3931cd1c5f1bc9e1e9dc7d42f997bc46ce880ef170ef4e86ed11bfdf11f9d94eb59848437dd5d28355d3a4501bb4364375645d644b0a66c2159adb978e75d0cbad0cce42b3aadc34266d31dc06f5329cb2de523a04f950d8de998ae04625753628ff950ef9f7d0f9c3ec959e30f219a909256e1be64577f75dba013cb805237fd9a1397feeb77b952d8b31e3a43cde6e587fc0aee53f3ba91d81b4740181e3474977f9938d1831df98b63ee61e85b1dccfcc60008aca3466a35c51fad281a721ca8be7a4781a907b85ba657271984e1dc649acbb695b4e9a381c4f018394baa4e3709245e6c2000b4fb44bb74f02b96be9d7376cc4b1ef61b81c24eb46ff93795f07b3d4c5c81efe3d5d82bc4474f2d760572fbfabe002822fb2f78f5ad1b1bd7a62ea807309eab11ddc663f191949dc325d77a47186300e8edb3358dafa8e4823c215a3cd340b0aa157c220af4384e50010391b54b0b67669a4ea8d9646409bb96219e5c70afd229903d8b09dcdd05825c8617e0bae4417cb30520215fe40996af48d929c500a40f5a586174e99e61619ec534dfb0815145859cf274c2901133cbecce002eb80c19efb8af3568ee2929c7e3846d6ffaf4050326616ee08bae1a563cf723f7e72dbaeae7d9bcacc101bb1ff7372a3192b944424244602b5ed27163cd1dc5f0bcfa37def7abed14db8a101b520f7fb630f55c1bde032d4cbeccad580cad82cdabdee1ae32397a2ba4c227ce0e9a056619cb2ceb1f961c2e62aed1320bfc5cb1ba2ba4138935b03222475883356f0af3174dc9c8c0234138391e4eed13f7b47249fe203e9282c90f99c3404c5e7ee151a8b7e67cb6f870016d9010febdb27a5ac31b55bfa94c2300580d43d7470aae4761f03ba19984d065849470df8689cc65cf64945103b4a8874afcf8e6b7a234c3569a44f676c45a9a789bd2763ad0c329adac8e0f67cbbf5773fc44752179ea3f6789d8f1c17c188f86ff95030a8eb37e38888453fddaf3cd0899007172c11f9c529062fa1ce2fb793a8e6789af29c31d326a8545b8a4ea7dddf0726bb4ed206dc94e7b3a1cc4539fc2ea372eeef641dc9b21f9a6fe87708a76f54820e14da55daf2cb2b41397229f1338c10452cac37203445f57bd05e889ee0f7bf1e52b98e6f39f90e3fdfd09ef307e15d8740111d60bd221acca71edbdb568e756d59c26a3d07ad3fde8f326ff5a331074106899e20cd26bd10698b2f76d697c4a6f7383040a3961dd92055508389a0e7d5c531311564518e9c3c3fed0291e2538549d2c0073ba2705886fbbf7e21b35dd92bb8c780e1e7011c8490f01b68bb361c7e464b2ce93ead7629d54f8481aeebaea3dcd39989cc52d4d2be84275e54a64c34b70fed51a13ffc3a9e09f3ded5e7367dc2fcff2980c59567b7f648b80869f6bc05131e7aa157cb19583a58989593dfceba9999aea04fe23bd8cf077b1f42578e1e8bf84a8c2afa7c6d25ade1bcce89983dd5d50fbf7d4eeb05e8ee4a992c9ce36df816f889069e1d570c584535f4f87566dcc6deb161efb59702af2850f1ae6619359bcf8fc306c1857297ea66534b6aba3ceb68f3c7a7898610dbf7151ec1a117e46783a4da193ca4215434f82c228894a52358388666032bcc765de409f2ce398a92cb3ae550dceb06bb46d83a2c416b0d0cc5e9cb2dab0fd704f7ee9c88c1676f33779285c9b24c19b1956945d206c6c6f235a1b3cf811592e5575862f618ceb34307df2131d43fbbb051c10be757f91403f314f8d9fdfd977d3a3f91faef151d5ce9f008f9a8b6eecbcc7ed8195542e46887132b312b53be391779d2385d966ad228762dedf7a129e63af5a3dbaa5af607f3aa9688f62c905c803cf340e5e1a29c0791ad42b751eb0ce49346c66cb9408bebd5f96d8abe0ec1f508ab5ef883b960b794e482594ca447d2871c442a7083f796e9284908cd125b52c3c0abc0ec224bfad48af6ea7b0356798f77e3a62971a00862e7510a895719720d0799b6c1168fadb6aaa94af93e2c7505d6d8026f0c8bac3430ecb5901886bd16c5cc7df492385c7706d6d0325d99ac80d0048ba1ad446b582c99b10676b31c76cb094f3d2dca53c842348231bd310e55db8d650c192cbcf284864287f0cfb7fd71b7e01182f3f6aadbce4e6183245e51affcbe256b4fbd2c25a4e04f3d28d82aee3baf2ca34ded5346cf79ed74409cbb6776d7ef897025f9c96f7e3b311f3f1e4956258e0454a3e6a5dd0666e79cd5233caca0c0993c999154b0d755c57097b038b34c32094547165873aa88cee3d208964d2f8f9df607f8c13d91fc40457d81a41ff91b7aa180905340d263927243a12dd043c679dd73352c3d3c16958100488076e3ada7882fc7d8a5878d5729a48ca2a9385c1f8f7f77cef6101056d6bdd91c91a52810b5bc49911c96ba60d9b188a9b3cd15dd78051427c7efda4e5e662a5fc92859249717e1ae913be221d34be98a63ca67ff40d981432d783cf1aae310a7680124784f1c58df405569dfcdc9526d322d3700ea207b3d3fd65c39c726af7f59b72b84f26a5b6387970054afae1c4a85944fd00b20154d3476afc967bd2bd0ba088043a8e6aa545ab8dbc024c3304ea13f40ee287b04cc193f379e3f1c9c2dcaed2e0705edc97107072ca73dbcf4e38dd19df0f4fcc7fc82b8d825cb4a5a86f2940c89d0f9cc8826ac8fc5e35504eb44bcb9df6aa45c57dadcb88003e032e9c95bccf158562e4922c2e36c883c35bd98513ec8315251e71831c47bf0daa6480e707ee85a6275775b6af56685c4e3a7d4726a80e4667dfb0e62ef3ef68b843016ff6a5cf65220d84ff4cb449e4b3e0b61d21e5751c2cdcb843197d08998affa668a53c4adeacb0bf3499050e1231260a5d7dcb48bf2b0547cc7e6b806ad5dd4885e12b0b5eda4552b7d0eedecc5b8efa008839ba07c00b4bd05f22014f2af3268cfff18ba46845039ea71c227dbbe7306eb568f0a9ca04a964beb9a1e379772c74d1428d7e952f193bc260135e38b678b67463708c7eba0d21d02bafde4f9cddba25b6d9415664f9b8707ed00f89d14a9ad22e19179aa857a02c1fe6c167de231f74b04b670d7eb5aa51bb7c304d3fa9a42b51322d3d8cb8c77e2a569519a29c5367546640a35452c058a11d84c3832b7582d42e8149a4093c99f67ab6dde54ee7c820af09dc43072c3a549bd9b598b3ecb248687a20473b4060cbbdcf0167a5c1eb46dbbe8df3d97c92c77216fa9e549068d100c35fa010429c77fb48e04e7cdb36f90f2e0668baa47b354cce960b9d5102bf9dc675b4dbf65acf0330248641dd2d60584816e2db2803f00b58bf945df544faec83900d61e8fb69c154a140f9a09c6e5ae3530af7f855d30e8863f5f8d124b2574e8b4eb4ee976f88b882c5498ee7f6a0ffce236733a98baa00939c5595430e4bdbfd42519c66b3d0ddc86d677bb33fb660bccb5cfabb5c525d4b36d1086462b2f185cc0f2dfd89ddb7a419b2aa3c165b4a9919396782d999d16d063a2e83edf75fa751e4678914271cb62c968d2c0448f51f6176639ec6d48cd1e57db8ed1d74c0a98430d49f48739b38a6daf8cc54efc6ada524b8e1b440aad362fcc37ea97e712967bf37bdf4752e61bae1d41657b8e83ad923a4197774a1a788e6412a976755554dbbef1353aea5e35871c8b4175589a128b7305650f6ce53b4a77a54a66ba3f3f941f7b9b9fea17e7698f2d2266ac5e025a32c40bd00c33cc706c824c9792c5ee97ec8f789251d297b9e66cf364f125169cb3e8f752d9a8fac8eac1b300c1fcd6c90f997c442725d3bb92022acf15aa0c42f9f05cc761d311492ab309d6708bcfc0f078de58a7faf9b4099b96c61645b7da95b65389c0bdbf44e4038d49c6b2b5bc54aadf99a1d51cfbe47be36fdb25251f4ef240af833f13901656529b740992a38c60c2be8def67a7dafc3795cacf632e573cb63f34126426350df5c1d1001b13e2118e40e6c1c59e221815c709e336b51861687a5df7367ab65777fa0363ac3585cce410934e6e7f58b17f1bc1ebe117d9b06379e0744bd56d777f2aca1f963abfd9886db957905944488ec3fde03daf1b77005f490881e9d8e2c9c06f7c7b07746d2e4bc37427440c7ea165bc838fe7a8134124319e2d2a4912ae7b54f4243c7ba3100fe0d8d9aec4209d7f00707684a137b445eb5de8d8349ca045b9bbf7fe7c619499d9a6289f0d0c95bf9877308c41b57aa9b3a1ffafcef139e411dff525c74061882ae0ebf7c7cbe2b1fa10f82a028715c110ee56550c399dd94b3d9175e0c4b8c3fe36355e5c67bcbecf9ff2b9b09d3dffeed2444b59dc8934f07b395647b33f7dd81bc60f6ae991aab01121c14a3069a67e161b469c4590b7f5104c2d4ca30bba2d103726e1d66873df8e1d13f4acae91478b19a05eb5eb09100c67beb924e8db8a3e3478776cde7bc46d53a85db61ce8419c57b235ae25bb348cd95db5002d09742436d2aa1a4c0231cfb46964c37f840e848f8e55401558864f58b23dbd3748cdc9c14d0fe7c2c76862817b37abd7414253f90edb0e7717b9135ec3ff39542b921cfeed92b2c1f6d94fe12fb66375a2e792c591ef5825ffeb692a9adc72d38e0b0edef320c011524985980f1baa76bef8eac4df45d25533425d251f90ad57168215946770d8a9704f83559ed74e8fe64c3d6779e806eefda8caac38fff83123eda35d7eda1cf5de83fb98cc64138d474496ecf340e6fbd38285231c242a10c1b5098f1617ff7511f79a19d76c2c4fff9877eae911d41a053db3f27e76a3bf83b225010a214e904c2362da8726cf5dad870f28c2554ae3821d3ec3557293b05bba74fe2d9882d07747f2b977305f5a1b96ce4e50f9bb8787e870644d4f5b581be1a3236c7e94429ce0f5e9f3af27b660dbaa9c80e613c2d962d29a22b72849c005ec7c1606150e927d7f690177cd326dd8e773b0c7b703c29a0e81b127d624bad84651fbabc3b2135b6455a2c15f99f5ce8385989eecfd28b4bed5d08a32d2a641d2aa156701bdc2e11af44b10bf408225344518cdf68576138c22c12486d3aaf8616b2ac3d83b58dbd241161f1e37d398f27743c65c27253ac23c38cb464cd8f9aa4ccc49222bd01a0cab68b832a5b21f1895513baa8ca09887a2805815ac3bf0342c64ed20466f924d1ec702c58c451139f30ed771886a3384ec1e598f4470fea77de1a76a9dec400f3cd23d1e08c431dcc2bcaca8bd03d9c8919b5c6aaf25d9980b83881ee8eb0a950860b74cfe94dfd6500dd163d7ceb06506c7837f9531a205678762d5e9638aedd18342220650f4780be343c6fc120b5819d6b61f818c9b759acebd004a46bff5aa4c74e1c63ebf167588f7d2a4c46a57e49216429befd335403cb4413348592051a9bdddcba5e802e6ab221881b7d34ffa3636069d38e5cb373a0805ce1a61269765cc82e156aff1baf","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4da7ee199f14414f34bb8e4b9490532e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
