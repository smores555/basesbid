<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"148cda784fb885a9adfbc18edb6c867537a850456fad081e165193a6ce79c0589394061c394b7242c20d01a690aa95c88b6b9e15941c17de9d9be08de0b53d9b56f31f7f2e266afae5832f36fab5177ce236f667f57627c0c286832d8c4a42f489f3d375d7dde385336c90fcb2e7bc933ac3691dfbc736b1e3e1d2ab9d1829347fd4fb9b5c3f178fc7463579c285c61332a9abc4ad0437b5f694b16ea395aeb5ddfab293322f837fc78fbca098e61ab0bc7ae223b8e95bca2b6429a047f95cabb20a04b45b96173f051c004008de89225bacc9325637f05e86ee88cb1812733b030254d2f3305f14f849f231e1bf670619dd70cd2320232f61d964fdac800461786c8f159d346220d9f3ac345e32c9ac1a61da7b142ec3b94b0a61bd6c731ac3eb172037c89f1f3c6d087bd178c479001ad98f1648e1fb5abafc821c59320fbed77050dc266ab2100fd5909178ce5c81820b30cab2786ef2da96e3ae64cbf716b99af42c555f9070dd3c21c13b6d440f42870b590e56af9d3f90aca70895ca74a5dec0550d99c5a0e7707f41e29dfe77f3ef635cfa03dea30209d116b8f0e494dc8bcfd1312eadd6c5ca75668207cd9634f05c99bbf97e9fa82e0f7a8e763faed043945ddb2699a92bb8aa940309526d25f5ae5eb29d66461b9289ef5cca4cd03f21bfd773a2a8f7be1d0e3095e678e5443bd7322189f1bb4d869e5e210b2212ee7c641b527bc7f1922508e4e1286efec4bd48a0e98021e08afd1f8ecb1dd17dec56fcd913c4b2d944819e4ce0310a4dfae2beb3ea8daf46c7cf059c7a77a4504b1620901a4aa6c58e766d2b450cd6da8089753b8cfd3fc347213d01ca68b03005b505fab0178446d38d2a082204a2c5bdb8cacd8f064c841b548d446ce109decd33e67eb2d5d4a81726b2a42e9811474535109d20b3dfc5c2662bc6fc960e391f342111951e2dde412b2b02324eb8509e7fd2f74087690c5e737a9b223ff1623d2c38b5519254ceda365b116726047b7c14075af2f978a5154811b747adf39e3066a5dff7d54aeba6858b9410efd10d6cc13f1ae9453ec375eefe8f8b7919c8a73bdeeb3132f9599c3fb303e26a984e39bacffcfedec96f829b385de1b5d72b3019893b26b747d7fed2872c45afaa9bdc61d6869c020784ca2988d886bf18ce6e2134dfec9eff7a4e54ca9c1eb40e60ee3e91eb4506925ebe4adbfeae1b6ca6af7035e01ddb59516e90a8ebe9f7d70837fd7afef4bd60ad57fcb37d056e9c801ae7022282ff63a5c5b0de87a54b179ab901a08eb87a525ce8404fc2612ee453121591ce31f084e15e7a3da37f109365959420bde9d24cbe145f240d6ef2182143c1ef95221d4856d90ed015a68e306569f06f66f1957ee3c653d874b49636e7bb5b1d8e6c26e5fbc0bc7cff504cdb301950df9d74b6af014ac9072a07c71c73d91006cf6ef9f89eb3e1b0cb5c68763b02e254e199075fc9cf438ff7ac3182b202a250ce1b525c3342202a92f68cffccadde505139869635f5a2cea07f1876d2363d464fd3344ea5685da3af3058ba0bc200af1f4b3bb43e8c3b4ee8aaed6de857f66c5de111beaabc2b52f49d93efe2b9a92f69c4e8b0374282bc9b9016947aa0decaf7c07b16580b4383faa00c774323f184e13a76d786eba1aa9939b806122a1d83eab11bfda9c892f391f5a08b5666d6a038204d7f897a15c23174e1d0758efaa832f86d0c5182cfa28be8652eb69a2c45b0770dacb7671b11b079e7c1390b72a663191ea8d70b69b94caa05072c2fd2ff4cf7d80d3bad66741f818ecf18f9c0557a91e13329a34259a7bf55ddbe47a907ed0402cb2ed2cdae12970f02e5868ad101db371330e0acb6d15a5b9a9b132cb2fb50c3cd704056b0e7f31d4ab187609700b75ecc659708726864dd88b55bc644a3c29914e52540ce492b042e38ece181e2d74ef121b99f3748558677758556304645b650ad50e1330e30dae64ba206d62a779d8c2e66e832005794c530b7ad81aacafb5599d75f1b6f1dd8943891533e91b9e45a4d99d52517f8248990ce8814dd050f85a62b2b0582af6907179a12b073585bfac51434efd5f06710066eb2fa22216e0aad00463c3b5fbe4423d93155dd5d81e02dd97b32b8f54a43676810a0a93eb8be30d4a2ec26db98c889ca53952f457646dab3bfe13719ff7fd0de541ee44e4d33ca03baac1e23c3a27933be239e8061baafcfc000e3468937d9d22afde03747cd27e221c60dc54cbb69bda5814d3d370683782eb7e0d6b143f819c9e571755e494242d133866a084d73ad0948766441b741d95717981d353f9a5fffbe418317c50e103824e13746c53b3487e06b3794eb2854dcdfd7e3a58f925d9abb381afd2fe9be1e59bdd10ac1321a55c737ac51ba45a7eef358e06e0bfd9810485790c01d901e9c97f215f3e2f024e1596f6d0ce92295f801395b1583373273e938ac99772d8781bbd6018081e8cbdfd69005044bbf4dddc78f2c0bfd72aa52cc2c89e381843315cf41accc5bca06398d0b4b11b07736fe20e87c957b725a1c58082a3d48e77535d650d8dd084baeaa015ec67c532751fd3b6f0cd09ef9492b203dfd2eff97706c2350224e5f0665eb793170e150ccff0755fc176d012ab2c8b56aba20c9bee64c181128cec09f9641deeef97be220fad2d7bad38482d8bb7b6bdf2b44bb9ccdabe2cd37faa7ee1e693e176b8111accfe4b97768092819f175377c53600e26f3c7f2991eb8976c700e3e9562d852c317c442e50b69dc0e5081afc1a61ade1ebfe759cbb7f901a91c456f6effa609c032429dccf3c327b2f4cedb1caae4ce45432932554f8836d8acfc088b3ba5bdd7c7a15f2ca9fb99d669309252697f65fed45fed13a865039219515d4ec4e4eb5b774c7c373dd5cbae2fe67b84b7b4d9e72004b000e16bec8dc15c98e4941b4f8b71542ed30846bb086382fc31b0e8487afea4f6589572ef458a6844412d0c244647aed8d27c4c5bf7285b7d0d844c73881d47a1761fe4c67ab686e9063bfd93e5831aba52583fc3b7e31694ec1856c7a207364f23832f15ae585a524262cde25c4223597cb3303ee560da693e7d9b05ccab9d861c7ff29a9a86a64916ced306966180f5fb804fbf0d22ac1c0c5f0a386df3d46c47ce0a21cd8e46d0076faa6d3eb01d20ab7aa2c7a65f7639ac74fc730a843e9fd514b42e4b5af1eb709195e820c20d46e4e4edd3bbd10e49c81c443a2d7c9776ef9ff925bce2afe6881a936af3947039473b03e4f41984954099403bfda12e4948e54bed18b73b5b296a6683a4698cc1ace744c80da0d090221cd470ac1cfd02bf33e6d04310c9c38d823eea1a5caf3251e9919bf69f8c6edba1f0392c582f8e1b4d4a43e2d3ed71a756d2e095502adcd6788cd0563159169cdc44712630042c3bfa7cb372849867a50d0946c0aeb4462d3b3bfc0e9b4b75e9766387af30b5820c10f3cfbaeb2b50d840ec863b029686ffd8d6650bc1bc92ce9ef093382976b314ed5a8787d548da3f7c459c693dcd8f07f2d2bf0054d74ce60100db84707d552e622854f4725484f827c9bf095c4a47d626e99a54f5a51ba9307d07954ffe4c2c4bf6747f8ec153ecdea0f12a2287fd578a05976cba07def5ca6ea4cb99154399c998900f862ede7780695bbabdbe97288901690b496a569271bcdf901ae5dabcaa264ce5ee133454202f89b11741035ac102cf40c87b9f5622f48ab8e8c01646c06dc828794e9b411e8c1f5b95f12dbcc2ff2431c1d10c4fa36157298731fa3e8caee9ac28c046686ccd2fc1b516c3d5e9e3816f9ac319274816b0bc4b41c91982ee14b7f67e5c520dc846fa8d3da11d10dba0a74c74ceb564373dc7844afe36efb3ceb8c2974fe23972d1bff083fb05626b9f95eeb6b3c2b3e83b2cca5e5e8684850747f21f4e696a1d0885ca4ba61fc13871de2e72186d5609e400894edf1f63cc7ec4a19ae2c09adbbab7b0e3c1e855358b8059dedbd9d474a0071518b8246755439b451f488a8a75a987817a469daf0f15ea4d8bbc949cc426448d933af6e5643280246a1b4aa28a7984067b419ddf8a47fe857584cd67779d82a38e1834e1528b23f1effd0361822d8785a38a866f3ed42acc2c4d99a1007ecc71fcfde2fe7c5ba0089547aca433944211c54c1a60868b131ada7a74f22c0046564c96818933d8cc2b0178aba97f0cefe39c850e5463839b96ff6ea5e15215334ae698f18c73f5721e341ced3bfb766193c4568bc453b22bd3c3617712d8e03e580fd2e2f2f3109ab8133be109cf955be0dd8ba3cd4a55853e72db301cc9e54abc1325598986683918b1f613d88cc9d8f1f3d5c337f3c99acc5c6465b64325da1d9ad713e250899e015576ef2bb1185467b2966410c9a1055ec1e7b65f31ef4682eaac4d59b6a6d0ae33e702e1dba115329c9da878195102d1912b91977ccf6779b83e7ab43ba540e60b203cdc635260f1b572efdc2575bc0031f7d57bc8309a64b28483f248abbc91bf849d985d89a14ddb4ceafd8def3dc5c765f49fada7aec7c9afa040a01b59a3e5daea47704f6251d4d0e59f0d674bda3fd5c7df649c7449e938c94709cf0dcaf9df927127f4b49a5e57e5cf7d50c21624460122a686fef266575acc1eab89d6ebe655f8114713ebb96091d300baf8bbf4c2a626b181bf663385ade8498a901873e39fb7eaeddc56e01ed9b467ef0c10d10fc15357b13d457bf9237efef54de87ce972ca96565a27c1adb02ea8daa4b58ab65093694a3d754d909e209e522435fc86d5a43626919368a9ee4f842b3fe8776210766befece85607645dca544488f63558b1af15c04bb970dd3322c044c4a797ddc76c5074fe6c04e87f88fd31b35210a631872b1783dcb6ad143c40a8d45ad753150ab48db624d0b2e37e30a5a71dc7a254a1af238f093efbfc95930cca3fec6eadcee73988040d80ad8cd494873d1bd01fb440b11b79c1aa3a2e7d4d83af1b6b95a9720641e3b5b2db6474e3f4a952efa7d08c3c1550122e1d2ca41abb5dc0db09ea96b3045e4715fe623040ad010034c1bbff946de54a09e17067387a0d77df5c5c11de47d3ecf3df3a8580cc424f9b4245c04fbe4995aed17d645ec3ff75cb1c2cb6f7b14e318b657666b45f04cd02a72da5739e8ef19cd955bd18a7ab2ba6ddb492992f7857b07bda155fb192efb0f8067e196c8c65bea8046e78c33da5a361b59a27c59e0e6078259c7c3c70ba9fd5535584dd7843519f8ef7d852c89fc16727c237b0b6b14e3b416725556ca8d0930d94e3f700ac567ca5510dc64f35b869f7be16ad6f29424e7bed4825df0fbd7570615ce8a610cb21a5b943321b84355de1fea30c7be97948a512b596a402ff1d6801e0b779297ce3898894dc2b2226c29d8c8821a8d314dbbc0aa705d5cc0df7dd27e590ba99a5d24bb6e8a8e2f54f7dd8f149f7d4d5f9a0008b7bc4439a49c508fbb43dfb27c3f87dc293d8a896739ad7768be1e2dbcab4e3def57e28b6460cd795ca001027f02ca35d3eaf7e965ef3eb59607d1e2e4f588339dd3ce22f94518efe0a69c9a80243a3b9f69fad6b063fd3f2c25c22e784d3ceb2da04912ce41e88941f793c468c29e6ef50cf0e9893774762e9048915420739ff67cda7db9f4485b63cf10083463118b3c9e2b88c8ad901da900ba9e959cd2a4e5781a28940358539d288e1b7a29033bc01ff72bb1f84b0a74ec256de644375444538bfeccc1b59971f3d6e71dec8a0b7e6265dcc0cc7d5af13a0ce586e75402ea7b3867167b28cf2dd8b8a08911188325e2739b0f049ff67e4c290b1031636e08cb8bb74ead1ef523628d03250e6b5ce88f490d68d40379b24d648cedb3cdd01abede38b4ea60c0806784db05b0f3c92e5dfa42c97e4c6765eacd6d1be915b8d26a9bcd14ea859d7b488abd7fc59d6cd01959347ea0e7c601d8cb13fc5224350ef52f1dacfd341fcc605370467a5dcae2985129088af1c24d75028c3c4fbd1363e3a5038cc2646860d5dd05db7e6b7159a06ac6cdfa0703e6abf3763ee2c78e32f8147b7c7584559c8f586ba995a0e168daa092aaef171659f045e42dbde4ba50f42d9e6096220a838beb616cf1441fb634b9551e0b6626de7c3b5edca2975b243e90d36374e92d2eda0121e5c4e8afde07ede8efb831055011e20889c930137e94d3c88fa2030038b967b404531d833c43c25a1596b4ea96891276849306d46d013157a3f4c9579c14729e277af212c656a955ec47bea74ca5324e7d2f2d5b86da9a83513985ff3dfa2361abfbe93b2c3884fec1c5e75f3edf0343b3d044466797b393c4ccda61f4d7d1b2bc2506e04ea3d801d86ee3dc844d915520b5d1e6ca825f2836f3964636624d6a993e138a0d1443b016d78acb64706a02d633a47c22b0dd7d82190356017c177591a66c214296efae12188352bfd6adb40badb33581104a0ca934ab2094da08b06b7b562666205e6e7d29afd62d2133721af67a4a95a972d81cd2615e048ae17b0922130398484e27afd670fa8d4e90467f26ed6febada50eac9938d3fd7bdbf47f3a9b7bd6939b8df0caafe449c3d2ca1b09b0a5a355806fe9e6a20d92fe6a009b6d8a93e46c25268de1eb31db359fb823fb5c46e47981017230e9acaaf1d2853c94fde526d629e68250b5068d29a3a9c190434b990774ab66f1eddb2fd60136cdbb4d72737d4872c1e1de8194e7ab4ab5badef5754ce18ec6f733c7a52ead8c8f6f5639af3ae013b576ed9dad3868938474b9a25b39a5c8bb79b848f849d9325fd122ee35e85eca2ad4f2485acf74c3188799d6d06c26faa9498beb2810c0ac05052afd0fe921a63e76047071b78867f43347e7d679a07481715f48d7870bc60a167db42303a81e9c9d8db4532c727233660d131926229fb2330e0da606afd0206b02ba5d5da46706ae6442cecac538138a6a77e1cff2f93789cccdc1b7591a622fa80684f10688c54c4b012d30f0b085b618a4a28427623a8e399d36e70e758aeb956d7bfc9cdbce8bb8ae74e406bd2b88fe616ca2de11d69ea23a49e66cbfac0376657c361177fba78264e125593b4aa25949d00f2e4fc13142654e634c964eaa35a1783c782a39e0d2db596227c5182dd45299a15de1022c30fba93a5ecf1729d93ff467643de6fe4e4846ecae3105dd050f026db3ad456847982967cc6db76df1a8afa3e884b0e8ae2e25789cd994608d6d9597c2081c59c142c0f233c41a179fe65e50fde6edcaf4a7cf16d30fa0e1540a72222cb38647549e51f84f5bae99cf6d31beefcf6e49dd30169b90ce0a57ef84d49a1f36294d89a8f922f2489728b27c9a9b48a162ae465208f6d100f1b7029647a06334846e759ff542ac00035f1705adee9dbb99a95acecb295e411c0da327f74cb30329ec89e70b9322f41f3a7cdaac587e31152f07036ee97e594f1f7d0032d3adab99c18f5598db92031c7f97dde3d9293e0614ccfe75a784f3838ab3f296cda559e513cd1ad1497f959fb602a96feb57b1980d0bd4ef4c166be962630b2094219d1c72183f4474e293c7e014353ab37543bb454f5fc79be24b61e76cfb572e386a85dba61f26482a36f32b20bbc1df24d4b5288fe67f0fd8c2374f2650fba0df70c658e0223a2ab646c8c2fee1e152bd66b6d6408fda3369142080d8fec200f21ce0918c33d3ac4a5aa454ad0456dba9edc9cbe0ad9f0811ca5b144195d4f9adeec84aa1391163ce11bf5fafaec517191fd5a875dfc5c71e8f2f4de548e1bf9ae28191bd07155e03d40e37c59d1f8910d91667c789ad2884f531ff3634c738481fca94a649c214e54b4f5f10c2bb798b46ca3fe93d767c7e5df2f608b2598b7694a63fa4b2ce4deea701584ea1128662f66cb0773a84bd7ccea68cfd2825723b158c117aea3a44b7b0118ad46fe650e545b7cd23fb98a99621fed73fc0925f6b9f0e7efa8d2628b55247a5911154827b0e5ca480cc2a2729700ae88b94795e3c10862d5091587e7c4e890267d0fa83178dfc9ecaa776177fe9fdea877fd2522846fc36a306ae289540dd6794bc5f16ba240d99a1f820359282453b6624de2cb0bf325024fb81bd5a0ebe10bfecc9a7503f596e1f0b587ef7a5924ba55e2199dd2de31cb6e05ec4ff7fc1e9a4061dd2d2fc88ff35e49b82e8e34f222d2f93c660a5c46b1007bbc12e74e07d92802671d37fa27d9dace33fb8150b0aa82cb55102c792a3c9324a1d218e671dee9dd9053dc37b8107af2b14b190eb0db401ea67e12b6b8162e1bd3698b00a2fd58300775b589b3f0e0268b111279bb6a20618296f7ee69d4b9e4be1b1931b3cee60f2472cd0a5fb30f78fa7e803c0630ebf8ae3b404f8b37e0442c08381003a87189963138b6580cf95689aafc5dd3177e191ca2be90a82739456b7330b8a9e2e9f10130d51449e04728c00315e00d83081fda285c71677979c7ee9ba640d1925de332b5e4391630c89d3be0fe59d4015d9ca6f4cf4628816f11987624c3d48cf04b15af626785e6a2d47992ef26d1378fe2b0064a5e94b69823973387e30901b1649e977d761d6191f5dedbdc450471cb4f0f62140c0e75843d912bb1eeb7321e40c4268ec0bdaaaba1800c5c0c299742dfdd77f1c31f17a4bb300027944c9a2ad2f6a3304bca463844bf16de7a8bf13d8f68d8fc1e8369dd371c19f1b2f865de9fe04e2fbc3d1ae8e5e5dcb05c8cae848540d60f676d8984cbe659e4dba5ef47da5ee79c621e5f3d117de4e3017bb959bd3d3572db605468c1ac2a8b477d00cc9f85cf8ddf06aa0c01b52a67e53abf0dbf17da580423293b4f43c4ef09637bf0ceb331d8145725664d943844267bab90cdfaaaa1f852c5f45fca550d6135af52b70893daa928f1ce5af305aacddc31956f1acdf56fb5b9becbb91022beb3c3f22c961cd1dd303319095d4e268c7b91ab0c9d01c7b772649f5b48994a26e9ec31cd5d9f05cc5f6afe97ce27cc59540108e98b0f59b58ab03361992149d0cd61bd827ee19e8b783e1d95c321a6262b016fb31c342c7ee186cf8de1ec89f4c5df2369379ac61b7f9d5a693ba5bd1800026d2889ac5189b68810b840fad09d0333750f09bf904174ef92b532b2878c416c86de5580d6ccfa725af117de4264804b701acb60a804db9f8366f20f56ea75429259c85933414ea9a6e2e313a7c06c7731c9cd5dd578b82afff4e2e50368aa4c11670cf7e6f536a8673f0ef5576f28f93dc5247bdd448df67d8c40d26d8910e50c627147794ec45fa46be653da59238c17833e3f3f5d312a0f42551c210c9a8ff7783da85dd996af45470e90986dbf805c9162210aa7dba2f866d51468a2013b1726b8f79204429b1565ff7488f39dbc3564319f98edfb7aefe2ff53f6ba1b56e881fdcaaf35cd489dace83c87d706cb1e80617ea26d7e49b99a5c4aa427a857fe1ac3456468453ded1b1b0d719569e2e2b27551d9aba630f89d5401eb732e3db3f51d98ce0adb87747ffc4c2866f1edfc741c6f3324cc9019890ca7c697635510e8e4dc5e0cea984d0ad6d592bca5c28272d39770afa05963911b153d29c6ecc4ac6a222dfe91b14114c2fdba581d0ca3cc9188289cf7d2a745d0712fd7c25f7b5e090a8d170cea599f72a7de974a78a756e74e1b8c8f9ded5cc9cb9347ceaebbf0a2c6650e640996e433a884fb316cd6a74e7fa2638b963bc83c12ed7b264af9afcd972390815108a28d773406ba190da43e02454c051619527613ff6cfaf006242bbe628edebae62e68b7826d246c7695e05b47ff88536dc24716625e43174041f927a6c7f62c0cd19bda336ee331f4c6bdb5ee7bcc7052480402c7750e4f344145f59e82b076410ace74583d70e070de4ebc3876916babe4b5591b1b57c05802b95cdb8772cf8c9a22bd04b12daedcc19d793a7c44d4886180835ad02426f165e70e3ff25945b7be75876c0be178b3109cde5fdadd5bd9db8cc88f40a4c195eda7b58419a808d291e33631d2d2b283a98f54127bad32d601e8fbeb13d10843d6b2fbdf16aebe3f41deca8a1a2d4b097153a8e19359e139ccf9f84f42e835958bd8af4cc55699d96c543f6fc32cc5ae61e12e3775fe1e0e2b9cf15d067f224d8f74","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"052b4420fd3b5f68957e5d51a766e922"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
